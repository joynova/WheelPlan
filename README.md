# 造轮子计划

## 背景与目的
游戏行业是一个需求非常复杂多样的行业，身处于这样的行业中，有它独有的乐趣。
而如何提升自我，提高自己在行业中立足的能力，是一个没那么简单的事情。
造轮子的目的，不是去重复的发明轮子，而是实际的去动手制作轮子。把一些公认的算法，优秀的思想，用自己的方式表达一下，锻炼一下，让知识成为自己思想的一部分。而不总是去google去百度，xxx好还是zzz好，而是能够自己去分析各个轮子的优劣。
大家一起造点轮子，而不是一个人闷头去撸，可以有效的提升大家整体的一个技术水平。希望最后每个人都有自己拿得出手的东西。

## 哲学
综上所诉，我们轮子计划的哲学应该是这样子的。
1. 轮子要足够小，至少分享起来要简单
1. 轮子要足够独立，仅仅描述自己的那部分思想就好
1. 轮子不脱离实际，从demo拆分出轮子来

## Demo1
手机版本的war3，大厅开房间模式，靠纯脚本来编辑地图，能够支持各种各样的玩法。整个demo毕业应该是以每人一张图来划上句号的。
### 服务器
1. 无锁跨线程消息队列
1. 无锁内存池(预分配的内存常常是可以提高性能的)
1. 一致性hash算法(虚拟节点与主动动态增删节点，异常删除节点时的数据迁移处理，负载均衡等)
1. actor+rpc的soa微服务架构模式(各个服务器角色以及与客户端的通信模型，每个actor是单进程多线程的)
1. 分布式集成缓存nosql数据库(nodsql+orm+redis,如何对数据分类，哪些需要缓存哪些不需要区分读写缓存等，如何让缓存与数据库自动化备份，如何减少代码量等等)
1. 数据热更新(大服结构通常在修改数据库结构之后，需要刷所有的数据，占用大量的时间，希望能做一个对数据分版本的处理方式，只需要处理数据结构版本迁移过程就好，可以做到因为数据结构变化的数据更新时间为0，而在使用单个数据时才对数据结构升级)
1. 逻辑热更新(把每个角色的实现都分为，状态部分和逻辑部分，状态部分的更新走前面的数据热更新部分，而逻辑部分都要设计为无状态的，这样子逻辑的热更新会非常简单)
1. 自动化集群部署工具(应该允许单进程启动所有节点以方便调试，允许多进程启动所有节点等)
1. 协议流描述工具(最好集成到协议结构的idl语言描述中，这样子便于掌控数据协议流程，也便于直接生成自动化测试机器人，也便于通过idl语言就查看整个逻辑流程)
1. 硬件监控工具(硬盘io,网络io,cpu,内存占用情况分析,代码profiler等,如果能集成到业务代码中，可以有效进行一些硬件过载的异常处理，不能集成也有助于分析问题)
1. 单播与组播功能(可以通过利用硬件的一些特性提高广播的性能)
### 客户端
1. 定点数学库(实现基本的四则运算、三角函数、开根等初等函数功能，并对比各种方式的性能优缺点，例如分子分母模型，缩放1000/1024倍模型，10进制表示法模型等)
1. 帧同步模型(难点在本地前进，回放，定点重连等，需要将实际开发中对逻辑的影响降到最低)(并且当前的帧同步模型其实也存在好几个版本，服务器需要等待的，服务器不需要等待的，同步操作的，同步指令的)
1. 结构化地形+rougelike(rougelike对自定义地图的提升其实是非常巨大的，可以提供更多更丰富的玩法，实现的核心在于结构化的地形)
1. recastnavigation(自定义地图的另一个难点在于寻路系统，现有优秀的算法recastnavigation，可以来了解并实现一下)
1. 可破坏的场景，物件(一棵树，可以砍倒，漂浮在河流上，借此，就可以过河，等等，如何把这种事物，做到场景中，并与寻路生命等挂钩，是可以实现一下的)
1. 层次化ui系统(理论上，UI系统的表现与数据逻辑应该是完全分离的，这里想做到的就是ui表现的完全自描述，这样子往后的脚本只需要关注数据部分就可以了，具体的ui表现可以完完全全的自定义，例如这个控件要显示那个数据，这个控件在xxx条件下要使用xxx数据响应xxx事件等等)
1. 编辑器框架(有了自己的层次化ui系统之后，就可以考虑使用这样的独立的ui系统描述编辑器了，用自定义的语言来表述编辑器，可以在未来适用于各种各样的引擎，并且会更顺手)
1. 自动化图集(客户端的ui，优化的重点常常是各种图集的引用，手动的图集处理存在很大的麻烦，例如如果处理资源的重复，如何去划分等等，自动化图集的目的是依赖于ui系统的窗体分布，来合理的规划图集，便与提高ui系统的性能)
1. 资源管理(资源管理在客户端来说，从来都不是一件简单的事情，如何保证内存的干净，保证资源的卸载加载时间，如何管理同步与异步的资源，资源相互间的依赖关系，等等，可以提炼出一个完整的管理模型与工具库)
1. AI系统(常用的ai系统有，状态机，行为树，htn, goap等，实现一套优秀的编辑器来处理这些ai范式，并且在性能上做一些突出的东西是很不错的，如何去做到不同的ai范式兼容共存也是可以提供一些解决方案的)
1. 脚本级技能系统(让技能最后由不同的脚本来实现，并且可以适配不同的数值体系，是不是很棒，把技能拆分出来，由动作，法球，特效，事件帧，脚本逻辑等等构成，只做表现不做公式。)
1. 结构化剧情系统(如何把剧情做到可以脚本化，随机化，是一件不是那么容易的事情。)
1. ik算法(ccd,雅可比矩阵,骨骼限制，朝向等算法)
### 通用
1. 自定义的json序列化库(想要可以自定义,静态变量,属性,甚至一些特定数据结构例如hashset的序列化方式,并且比较一下一些库的效率)
1. 自定义一套通讯协议，现有的优秀协议有很多，protobuf,thrift 等(理论上我认为protobuf是现在最优秀的通讯协议框架，但是它也有一定的局限性，例如rpc不够好用，例如不支持一些特殊库下的数据结构，例如unityengine.vec3等，我希望直接使用protobuf的序列化方式做一套更容易分布式的方案)
1. 可靠udp通讯(市面上有名的有kcp,enet等，希望理解其中的原理，自己做一套可靠的方案，并且加入一些动态的参数设定，例如丢包率高延迟低，延迟高丢包率低等，针对不同的情况，自定义一些参数，而不是丢给外部一堆参数，让别人自己去调，参数应该在不同的环境下具有最优的理论值。在此基础上，去测试与现有库的性能对比情况。)
1. excel解析库(需要支持，编辑器下直接读取excel,以及手机端转化为二进制，支持编辑器下修改excel的数据等等)
### 工具
1. 特定领域语言DSL的快速编码工具(利用这套工具，应该可以快速的写出例如protobuf那样的idl语言，并且方便去制作自己的脚本语言系统，例如技能脚本系统，剧情脚本系统，等等，理论上我认为需要的工作是一个文件语法词法解析工具，以及一套模板输出工具)

## Demo2
纯研究性质,用于一些兴趣技术积累
1. motion-matching
1. q-learning
1. 自定义可视化脚本系统
1. ecs